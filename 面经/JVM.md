## 内存结构（重要）

### 程序计数器

- 上下文切换时，记录程序上次执行到的位置
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，实现分支，循环，跳转等功能

### 虚拟机栈

每执行一个方法，变生成一个栈帧，栈顶的活动栈帧对应着正在执行的方法，每个栈帧中有：局部变量表，操作数栈（主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间）等。



#### **方法内的局部变量是否线程安全？**

- 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全



#### 如何定位有问题的线程？

- 用top定位哪个进程对cpu的占用过高

- ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）

- jstack 进程id：

  可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号



### 本地方法栈

执行native方法，也是生成栈帧，栈帧中有局部变量表，操作数栈等。

### 堆

创建对象实例以及数组在堆中分配



#### 逃逸分析

如果对象在一个方法中new，并且不去return或未被外面使用，那么就在栈中为其分配内存！



#### 堆结构

新生代：伊甸园区，幸存者区

老年代：。。。

JDK8后方法区被改位元空间，使用的是直接内存。



#### 如何查看堆内存

jconsole工具，图形界面，可以监控堆内存



### 方法区-->元空间

运行时常量池



## 对象创建过程

[JavaGuide (gitee.io)](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域?id=_31-对象的创建)（**感觉问的次数不多啊**）无论是面试还是笔试，都没考到过。

## 类加载过程

这个选择题倒是还考过。

[JavaGuide (gitee.io)](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类加载过程?id=类的生命周期)





## 垃圾回收（重要）

### 如何判断对象是否可以回收？

- 引用计数

- 可达性分析

  - 那些对象可作为GC Root对象：虚拟机栈中引用对象，本地方法栈中对象，静态变量引用的对象等

四种引用：

- 强引用：一般的都是强引用，只有GC root不通过强引用引用该对象是才回收。
- 软引用：内存不够时才回收
- 弱引用：只要GC就回收，比如ThreadLocal
- 虚引用：主要用来标记对象啥时候被回收

### 垃圾回收算法

- 标记清楚
- 标记整理
- 标记复制
- 分代回收：对象首先分配在伊甸园区，伊甸园区内存不够触发minor gc，将存活下来的对象放到幸存者区，幸存者区分为from，to，每次gc，则从from到to，并且年龄加1，年龄到一个阈值后，则放到老年代。如果对象过大则直接放到老年代。如果老年代满了，则进行full gc。

### 相关vm参数

-Xms：堆初始大小

-Xmx：堆最大大小

-Xmn：新生代大小

### 垃圾收集器

#### Serial

单线程，就是只有一条垃圾回收线程，并且回收时暂停工作线程直到收集结束。简单高效（其他收集器的单线程）适合client端。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![image-20210910085409596](https://gitee.com/keke518/MarkDownPicture/raw/master/img/20210910085416.png)

#### ParNew

**ParNew 收集器其实就是 Serial 收集器的多线程版本**

**新生代采用标记-复制算法，老年代采用标记-整理算法**

![image-20210910085449795](https://gitee.com/keke518/MarkDownPicture/raw/master/img/20210910085449.png)



#### **Parallel Scavenge**和**Parallel Old**

提高吞吐量，高效率利用cpu。吞吐量 = 运行用户代码时间 / （用户时间+垃圾收集时间）

比如总共运行100分钟，垃圾回收1分钟，则吞吐量为99%

高吞吐量可以高效利用cpu时间，尽快完成计算任务，适合在后台运算而不需要太多交互的任务



#### CMS

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

比如互联网站，web浏览器服务端，等都是需要用户体验，想要更快的响应速度的。

使用标记清除，并发收集，低停顿。

缺点：

- cpu资源敏感，当并发阶段，会占用一部分线程，导致用户线程执行慢。cpu多的时候影响不大，cpu越少，影响越大，比如只有两个cpu，那么其中一个为收集线程，那么用户程序就会降低50%
- 无法处理浮动垃圾，在并发收集时出现的新垃圾，无法收集。
- 产生大量空间碎片

#### G1

面向服务端应用的垃圾收集器

- 并行与并发：利用多CPU，多核硬件优势，缩短Stop-the-world停顿时间，其他收集器需要停顿Java线程进行GC，而G1收集器通过并发方式让Java程序继续运行
- 分代收集：不需要其他收集器配合，独立管理GC堆
- 空间整合：采用标记整理和复制，不会产生空间碎片，提供规整的可用内存
- 可预测的停顿：建立可预测的停顿时间模型，使用者指定一个M毫秒时间内，消耗垃圾回收的时间不超过N毫秒。





## JVM内存溢出排查？


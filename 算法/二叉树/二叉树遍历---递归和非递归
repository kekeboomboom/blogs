- [ ] 将打印边缘节点的超链接写上去



之前为了求快，认为递归和动态规划是一类的，导致做了不少递归的题但只知其思路，但就是没法代码实现出来！！！



现在学习二叉树，我觉得对学习递归真的很有帮助！



## 二叉树的基础：遍历二叉树

二叉树遍历是基础，如果我们不能遍历二叉树，又如何对二叉树的节点进行操作呢？

二叉树的节点：

```java
/**
 * @author keboom
 * @date 2021/4/30
 */
public class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }

    /**
     *          10
     *     12        15
     *  4     7    5    18
     * @return
     */
    public static Node getTestTree() {
        Node node10 = new Node(10);
        Node node5 = new Node(5);
        Node node15 = new Node(15);
        Node node4 = new Node(4);
        Node node7 = new Node(7);
        Node node12 = new Node(12);
        Node node18 = new Node(18);

        node10.left = node12;
        node10.right = node15;
        node12.left = node4;
        node12.right = node7;
        node15.left = node5;
        node15.right = node18;

        return node10;
    }
}
```

`getTestTree`此方法为了方便测试，不用理会。



### 递归遍历

```java
    public void preOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        System.out.println(head.value + " ");
        preOrderRecur(head.left);
        preOrderRecur(head.right);
    }

    public void inOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        inOrderRecur(head.left);
        System.out.println(head.value + " ");
        inOrderRecur(head.right);
    }

    public void posOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        posOrderRecur(head.left);
        posOrderRecur(head.right);
        System.out.println(head.value + " ");
    }
```

以上分别为先序，中序和后序遍历。

先序遍历：先打印，再向下递归

中序和后序：先递归到最下面，再打印

只看简单的遍历太简单不直观，请看这题：**打印边缘节点**





### 非递归遍历

```java
    public void preOrderUnRecur(Node head) {
        System.out.println("pre-order: ");
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            stack.add(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
        System.out.println();
    }

    public void inOrderUnRecur(Node head) {
        System.out.println("in-order: ");
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            while (!stack.isEmpty() || head != null) {
                if (head != null) {
                    stack.push(head);
                    head = head.left;
                } else {
                    head = stack.pop();
                    System.out.print(head.value + " ");
                    head = head.right;
                }
            }
        }
        System.out.println();
    }

	/**
	* 先将头放入s2，然后将右子树放入s2，最后将左子树放入s2
	*/
    public void posOrderUnRecur1(Node head) {
        System.out.println("pos-order: ");
        if (head != null) {
            Stack<Node> s1 = new Stack<>();
            Stack<Node> s2 = new Stack<>();
            s1.push(head);
            while (!s1.isEmpty()) {
                head = s1.pop();
                s2.push(head);
                if (head.left != null) {
                    s1.push(head.left);
                }
                if (head.right != null) {
                    s1.push(head.right);
                }
            }
            while (!s2.isEmpty()) {
                System.out.print(s2.pop().value + " ");
            }
        }
        System.out.println();
    }
```

递归的前中后序遍历看起来挺有规律，但是非递归的就不太一样了，我是找不到啥规律。

非递归的前序遍历和中序遍历都模拟了递归调用栈。

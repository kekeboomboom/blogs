## 第一章：并发编程线程基础

### sleep

使当前线程阻塞，并不会释放

### yield

让出cpu时间，不会阻塞线程。

### interrupt

此方法只是设置了中断标志，并没有实际让线程中断，实际的中断效果还要我们自己用代码控制。

#### 1.使用while循环

以interrupt为while循环的判断条件

#### 2.使用try-catch

如果线程在wait，sleep，join时，使用interrupt则代码进入catch。

### 线程死锁

​	死锁产生四个条件：

- 互斥条件：改资源同时只能有一个线程占用
- 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新的资源被其他线程占有，所以当前线程被阻塞，但阻塞同时并不释放自己已获取的资源
- 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有自己使用完毕后才能由自己释放该资源
- 环路等待条件：指发生死锁是，必然存在一个线程-资源的环形链



​	如何避免死锁？

​	破坏其中的请求并持有和环路等待条件。

​	具体思路：

- 获取资源的顺序保持一致：线程A先获取资源A后获取资源B，线程B也先获取资源A后获取资源B。同一时刻只能有一个线程能获取资源A，避免了死锁。

- 如果一直获取不到某资源，则主动释放自己已持有的资源



### 守护线程与用户线程

守护线程在后台运行，直到最后一个非守护线程结束，jvm才正常退出，无论守护进程是否还运行。



## 第二章：其他基础

### Unsafe类

- objectFieldOffset：返回指定的变量在所属类中的内存偏移地址。

  文章地址：[UNSAFE和Java 内存布局_MysticalYcc的博客-CSDN博客](https://blog.csdn.net/qq_17238449/article/details/103498012)



## 第三章：

### ThreadLocalRandom

之前的面试高并发，对于随机生成转账金额，我或许可以把`random`换成`threadLocalRandom`。

## 第四章：

### AtomicLong

我不知道能不能把账户的金额换成原子类，问题是金额不够的话，原子类如何控制呢？？



## 第五章

### CopyOnWriteArrayList

add方法之前用reentrenlock加锁。jdk11用的object为lock，通过synchronize关键字加锁。



## 第十章

### countdownLatch

调用await方法的线程会将其放入阻塞队列中，直到其他线程countdown到计数器为0时，则从阻塞队列中唤醒被阻塞的线程。

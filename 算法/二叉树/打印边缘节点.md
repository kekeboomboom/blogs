- [ ] 完整代码：gitee

## 题目：

给定一棵二叉树的头节点 head，按照标准实现二叉树的边界节点的逆时针打印。

1．头节点为边界节点。
2．叶节点为边界节点。
3．如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

![image-20210517093814189](https://gitee.com/keke518/MarkDownPicture/raw/master/20210517093821.png)

打印结果为：1，2，4，7，11，13，14，15，16，12，10，6，3

## 思路：

- 获得树高
- 依据树高构建`Node[][] edgeMap = new Node[height][2]`，`edgeMap`是存储二叉树每一层的最左和最右的边缘节点
- 有了`edgeMap`后便可以打印左边缘节点
- 打印如14,15这样的非边缘节点，但为叶结点
- 从下向上打印右边缘节点



## 代码

二叉树遍历是基础，以下代码我会跟二叉树的前中后序遍历做一些联系。

### 获得树高

```java
    /**
     * 获得二叉树的高度
     * 通过不断向下递归查找，找到最大高度
     * @param head
     * @param height
     * @return
     */
    private int getHeight(Node head, int height) {
        if (head == null) {
            return height;
        }
        return Math.max(getHeight(head.left, height + 1), getHeight(head.right, height + 1));
    }
```

此方法我认为类似**后序遍历**。向左右递归，得到左右的树高，然后在做比较取大一点的。

符合先左右递归，然后操作。



### 获得`edgeMap`

```java
    /**
     * edgeMap是一个二维数组，记录树的每一层最左和最右边缘节点。
     * @param h
     * @param l
     * @param edgeMap
     */
    private void setEdgeMap(Node h, int l, Node[][] edgeMap) {
        if (h == null) {
            return;
        }
        edgeMap[l][0] = edgeMap[l][0] == null ? h : edgeMap[l][0];
        edgeMap[l][1] = h;
        setEdgeMap(h.left, l + 1, edgeMap);
        setEdgeMap(h.right, l + 1, edgeMap);
    }
```

这个一看就符合先序遍历。

先操作`edgeMap`，然后递归。

```java
        edgeMap[l][0] = edgeMap[l][0] == null ? h : edgeMap[l][0];
        edgeMap[l][1] = h;
```

上面两行代码挺巧妙的，仔细思考先序遍历的过程和规律，发现这两行代码正好就能求的左右边缘。



### 打印非边缘节点的叶结点

```java
    /**
     * 打印不是边缘节点的叶节点
     * @param h
     * @param l
     * @param m
     */
    private void printLeafNotInMap(Node h, int l, Node[][] m) {
        if (h == null) {
            return;
        }
        // 首先要是叶子结点，并且不是左右边缘
        if (h.left == null && h.right == null && h != m[l][0] && h != m[l][1]) {
            System.out.print(h.value + " ");
        }
        printLeafNotInMap(h.left, l + 1, m);
        printLeafNotInMap(h.right, l + 1, m);
    }
```

这个也是先序遍历了。

符合先操作，后递归。

先序遍历每个节点，判断其是叶结点但不为边缘节点。



### 主方法

```java
    /**
     * @param head
     */
    public void printEdge1(Node head) {
        if (head == null) {
            return;
        }
        int height = getHeight(head, 0);
        Node[][] edgeMap = new Node[height][2];
        setEdgeMap(head, 0, edgeMap);
        for (int i = 0; i != edgeMap.length; i++) {
            System.out.print(edgeMap[i][0].value + " ");
        }
        printLeafNotInMap(head, 0, edgeMap);
        for (int i = edgeMap.length - 1; i != -1; i--) {
            if (edgeMap[i][0] != edgeMap[i][1]) {
                System.out.print(edgeMap[i][1].value + " ");
            }
        }
        System.out.println();
    }
```

主方法与思路一致，不多说了。

